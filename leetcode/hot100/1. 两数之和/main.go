package main

/*****************题目描述***********************
1. 两数之和

给定一个整数数组 nums和一个整数目标值 target，
请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
*/

/*****************方法一***********************
1.根据题目描述俩数之和，显而易见，你的第一反应肯定是暴力双重循环
2.双循环是算法题最最重要的基本功一定要练到非常熟练，达到信手拈来的地步
3.双循环的时间复杂度也显而易见,时间复杂：O(N2);因为没有使用额外的空间所以空间复杂:O(1)
*/
func loopTwoSum(nums []int, target int) []int {

	if len(nums) < 1 {
		return nil
	}
	//因为是2数之和，所以可以直接定义2个长度的切片
	ans := make([]int, 2)

	for i := 0; i < len(nums); i++ {
		for j := i + 1; j < len(nums); j++ {
			if nums[i]+nums[j] == target {
				ans[0] = i
				ans[1] = j
				return ans
			}
		}
	}
	return nil
}

/*****************方法二***********************
1.方法一因为采用了双循环所以时间复杂度比较高，因此我们优化的方向肯定是降低时间复杂
2.如何降低时间复杂度呢，算法优化的最常规的思路用空间换时间，通过题目描述我们至少是需要遍历一次数组的
3.思路很简单，通过遍历数组把元素放入Map中，然后判断taget-nums[i]即可
4.因为只需要遍历一次数据所以时间复杂：O(N),空间复杂度最差情况是需要把所有nums的元素放入map，
所以空间复杂度:O(N)
*/
func mapTwoSum(nums []int, target int) []int {

	if len(nums) < 1 {
		return nil
	}

	//因为是2数之和，所以可以直接定义2个长度的切片
	ans := make([]int, 2)
	m := map[int]int{}

	//此处也可以用range
	for i := 0; i < len(nums); i++ {

		if v, ok := m[target-nums[i]]; ok {
			ans[0] = v
			ans[1] = i
			return ans
		}

		m[nums[i]] = i
	}

	return nil
}

/*****************方法三***********************
1.如果给定的数组是一个有序数组，那么这一题就可以用双指针解决了,双指针有效降低了空间复杂度和时间复杂度
2.因为本题没有给定是一个有序数组，因此此处不过多赘述,双指针就有效降低了空间复杂度
3.后面专门的双指针问题会详细解说
*/
